/*169. Majority Element

Boyer–Moore majority vote algorithm

简单讲一下算法的原理：

可以想象一个选举的场景：每个人手里有一张选票，来选出一个人，得票超过半数的人可以获胜

假设投票人手里拿着选票排好队，主持人挨个收选票：
	
	1.如果主持人手里没有选票，则把选票拿在手中，此时主持人手里的候选人的票数等于1
	2.如果主持人手里有选票：
		A) 如果新收选票与手里的选票一致：则拿到手里，此时主持人手里的候选人的票数大于1
		B) 如果新收选票与手里不一致：则放弃这个新选票，同时丢掉手里一张选票，此时主持人手里票数可能为0，可能大于0
	3.当处理完全部选票后，最后拿在手里的选票，一定是大于1/2 的候选人。

这个算法的核心思想是：大家往桌上放选票：我发现桌上有其他人的选票，我用我的选票和他同归于尽，最后剩下的，一定是大于1/2的。
在整个过程中：主持人手里只拿着某一个候选人的选票（1张或多张），或者没有选票


算法变形：

如果题目不保证一定有一个元素出现的次数多于1/2,那此算法失效，因为最后出场的选票往往容易获胜（更早出场的选票互相残杀消耗掉了）
算法改进是:当找出最后的获胜者之后，再遍历一下原来的数组，对这个元素计数，看看是不是真的数量大于1/2,如果不是，那就是压根
没有一个元素数量是多于1/2的。

*/

int majorityElement(int* nums, int numsSize) {
    int result = nums[0];
    int time = 1;
    for (int i = 1; i < numsSize; ++i)
    {
        nums[i] == result ? time++ : time--;
        if (time == 0)
        {
            result = nums[i];
            time++;
        }
    }
    return result;
}
